ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ¾Ñ‚Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ñ SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ğ°Ğ¼Ğ¸, Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ°Ğ¼Ğ¸ GoF, Ğ¼Ğ½Ğ¾Ğ³Ğ¾ÑĞ»Ğ¾Ğ¹Ğ½Ğ¾Ğ¹ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ¾Ğ¹ Ğ¸ Ğ²Ñ‹Ğ½ĞµÑĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸:

***

## **1. Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°**

```
claude-integration/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ settings.py
â”‚   â”‚   â””â”€â”€ logger.py
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ entities.py
â”‚   â”‚   â””â”€â”€ exceptions.py
â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ service.py
â”‚   â”‚   â”œâ”€â”€ dto.py
â”‚   â”‚   â””â”€â”€ use_cases/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ base.py
â”‚   â”‚       â”œâ”€â”€ review.py
â”‚   â”‚       â”œâ”€â”€ implement.py
â”‚   â”‚       â”œâ”€â”€ fix.py
â”‚   â”‚       â”œâ”€â”€ docs.py
â”‚   â”‚       â”œâ”€â”€ refactor.py
â”‚   â”‚       â””â”€â”€ tests.py
â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ claude/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ client.py
â”‚   â”‚   â”‚   â”œâ”€â”€ factory.py
â”‚   â”‚   â”‚   â””â”€â”€ providers.py
â”‚   â”‚   â”œâ”€â”€ github/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ workflows.py
â”‚   â”‚   â””â”€â”€ shell/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ executor.py
â”‚   â”œâ”€â”€ presentation/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ cli.py
â”‚   â”‚   â”œâ”€â”€ formatter.py
â”‚   â”‚   â””â”€â”€ parser.py
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ result.py
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ review.yml
â”‚   â”œâ”€â”€ implement.yml
â”‚   â”œâ”€â”€ fix.yml
â”‚   â”œâ”€â”€ docs.yml
â”‚   â”œâ”€â”€ refactor.yml
â”‚   â””â”€â”€ tests.yml
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ claude-cli.sh
â”‚   â”œâ”€â”€ analyze.sh
â”‚   â””â”€â”€ setup.sh
â”œâ”€â”€ .github/workflows/
â”‚   â”œâ”€â”€ claude-pr.yml
â”‚   â”œâ”€â”€ claude-api.yml
â”‚   â”œâ”€â”€ claude-vertex.yml
â”‚   â”œâ”€â”€ claude-review.yml
â”‚   â””â”€â”€ claude-daily-report.yml
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_service.py
â”‚   â”œâ”€â”€ test_use_cases.py
â”‚   â””â”€â”€ fixtures/
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Makefile
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

***

## **2. ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ: `src/config/settings.py`**

```python
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Optional
import os
from dotenv import load_dotenv


class CloudProvider(Enum):
    API = "api"
    BEDROCK = "bedrock"
    VERTEX = "vertex"


class LogLevel(Enum):
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"


@dataclass
class ClaudeConfig:
    api_key: str
    model: str
    max_turns: int
    provider: CloudProvider
    region: str
    project_id: Optional[str] = None
    timeout: int = 300


@dataclass
class LoggerConfig:
    level: LogLevel
    format_string: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"


@dataclass
class Settings:
    claude: ClaudeConfig
    logger: LoggerConfig
    project_root: Path = field(default_factory=lambda: Path(__file__).parent.parent.parent)
    prompts_dir: Path = field(default_factory=lambda: Path(__file__).parent.parent.parent / "prompts")

    @classmethod
    def from_env(cls) -> "Settings":
        load_dotenv()
        
        provider_str = os.getenv("CLAUDE_PROVIDER", "api").upper()
        provider = CloudProvider[provider_str] if provider_str in CloudProvider.__members__ else CloudProvider.API
        
        log_level_str = os.getenv("LOG_LEVEL", "INFO").upper()
        log_level = LogLevel[log_level_str] if log_level_str in LogLevel.__members__ else LogLevel.INFO
        
        claude_config = ClaudeConfig(
            api_key=os.getenv("CLAUDE_API_KEY", ""),
            model=os.getenv("CLAUDE_MODEL", "claude-sonnet-4-5-20250929"),
            max_turns=int(os.getenv("CLAUDE_MAX_TURNS", "10")),
            provider=provider,
            region=os.getenv("AWS_REGION", "us-west-2"),
            project_id=os.getenv("GCP_PROJECT_ID"),
            timeout=int(os.getenv("CLAUDE_TIMEOUT", "300"))
        )
        
        logger_config = LoggerConfig(level=log_level)
        
        return cls(claude=claude_config, logger=logger_config)
```

***

## **3. Ğ›Ğ¾Ğ³Ğ³ĞµÑ€: `src/config/logger.py`**

```python
import logging
from typing import Optional
from .settings import LoggerConfig


class LoggerFactory:
    _instance: Optional[logging.Logger] = None

    @staticmethod
    def get_logger(name: str, config: Optional[LoggerConfig] = None) -> logging.Logger:
        if LoggerFactory._instance is None:
            if config is None:
                from .settings import Settings
                config = Settings.from_env().logger
            
            logger = logging.getLogger(name)
            logger.setLevel(config.level.value)
            
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(config.format_string))
            logger.addHandler(handler)
            
            LoggerFactory._instance = logger
        
        return LoggerFactory._instance
```

***

## **4. Ğ”Ğ¾Ğ¼ĞµĞ½: `src/domain/entities.py`**

```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional


class TaskType(Enum):
    REVIEW = "review"
    IMPLEMENT = "implement"
    FIX = "fix"
    DOCS = "docs"
    REFACTOR = "refactor"
    TESTS = "tests"


class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"


@dataclass
class ExecutionResult:
    status: TaskStatus
    output: str
    error: Optional[str] = None
    exit_code: int = 0

    @property
    def is_success(self) -> bool:
        return self.status == TaskStatus.SUCCESS


@dataclass
class Task:
    type: TaskType
    payload: dict
    id: Optional[str] = None

    def get_param(self, key: str, default: Optional[str] = None) -> Optional[str]:
        return self.payload.get(key, default)
```

***

## **5. Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ: `src/domain/exceptions.py`**

```python
class ClaudeIntegrationException(Exception):
    pass


class ConfigurationError(ClaudeIntegrationException):
    pass


class ClaudeExecutionError(ClaudeIntegrationException):
    pass


class PromptLoadError(ClaudeIntegrationException):
    pass


class InvalidTaskError(ClaudeIntegrationException):
    pass


class ShellExecutionError(ClaudeIntegrationException):
    pass
```

***

## **6. DTO: `src/application/dto.py`**

```python
from dataclasses import dataclass
from typing import Optional
from src.domain.entities import TaskType


@dataclass
class ExecuteTaskDTO:
    task_type: TaskType
    prompt_override: Optional[str] = None
    max_turns_override: Optional[int] = None
    extra_params: dict = None

    def __post_init__(self):
        if self.extra_params is None:
            self.extra_params = {}


@dataclass
class TaskResultDTO:
    success: bool
    output: str
    error: Optional[str] = None
    exit_code: int = 0
```

***

## **7. Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹: `src/utils/result.py`**

```python
from dataclasses import dataclass
from typing import TypeVar, Generic, Optional, Callable

T = TypeVar("T")
E = TypeVar("E", bound=Exception)


@dataclass(frozen=True)
class Result(Generic[T]):
    value: Optional[T] = None
    error: Optional[Exception] = None

    @staticmethod
    def ok(value: T) -> "Result[T]":
        return Result(value=value, error=None)

    @staticmethod
    def err(error: Exception) -> "Result":
        return Result(value=None, error=error)

    @property
    def is_ok(self) -> bool:
        return self.error is None

    @property
    def is_err(self) -> bool:
        return self.error is not None

    def map(self, fn: Callable[[T], T]) -> "Result[T]":
        if self.is_ok:
            return Result.ok(fn(self.value))
        return self

    def flat_map(self, fn: Callable[[T], "Result[T]"]) -> "Result[T]":
        if self.is_ok:
            return fn(self.value)
        return self

    def unwrap(self) -> T:
        if self.is_err:
            raise self.error
        return self.value

    def unwrap_or(self, default: T) -> T:
        return self.value if self.is_ok else default
```

***

## **8. Shell Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒ: `src/infrastructure/shell/executor.py`**

```python
import subprocess
from typing import List, Tuple
from src.config.logger import LoggerFactory
from src.domain.exceptions import ShellExecutionError


class ShellExecutor:
    def __init__(self):
        self.logger = LoggerFactory.get_logger(__name__)

    def execute(self, command: List[str], timeout: int = 300) -> Tuple[int, str, str]:
        try:
            self.logger.debug(f"Executing: {' '.join(command)}")
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired as e:
            raise ShellExecutionError(f"Command timeout after {timeout}s") from e
        except FileNotFoundError as e:
            raise ShellExecutionError(f"Command not found: {command[0]}") from e
        except Exception as e:
            raise ShellExecutionError(f"Shell execution failed: {str(e)}") from e
```

***

## **9. Claude Ğ¿Ñ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ñ‹: `src/infrastructure/claude/providers.py`**

```python
from abc import ABC, abstractmethod
from typing import List
from src.config.settings import ClaudeConfig, CloudProvider
from src.config.logger import LoggerFactory


class ClaudeProvider(ABC):
    @abstractmethod
    def build_command(self, model: str, max_turns: int, prompt: str, extra_args: List[str] = None) -> List[str]:
        pass


class DirectAPIProvider(ClaudeProvider):
    def __init__(self, config: ClaudeConfig):
        self.config = config
        self.logger = LoggerFactory.get_logger(__name__)

    def build_command(self, model: str, max_turns: int, prompt: str, extra_args: List[str] = None) -> List[str]:
        cmd = [
            "claude",
            "--api-key", self.config.api_key,
            "--model", model,
            "--max-turns", str(max_turns),
        ]
        if extra_args:
            cmd.extend(extra_args)
        cmd.extend(["--prompt", prompt])
        return cmd


class BedrockProvider(ClaudeProvider):
    def __init__(self, config: ClaudeConfig):
        self.config = config
        self.logger = LoggerFactory.get_logger(__name__)

    def build_command(self, model: str, max_turns: int, prompt: str, extra_args: List[str] = None) -> List[str]:
        cmd = [
            "claude",
            "--use-bedrock", "true",
            "--model", model,
            "--max-turns", str(max_turns),
        ]
        if extra_args:
            cmd.extend(extra_args)
        cmd.extend(["--prompt", prompt])
        return cmd


class VertexProvider(ClaudeProvider):
    def __init__(self, config: ClaudeConfig):
        self.config = config
        self.logger = LoggerFactory.get_logger(__name__)

    def build_command(self, model: str, max_turns: int, prompt: str, extra_args: List[str] = None) -> List[str]:
        cmd = [
            "claude",
            "--use-vertex", "true",
            "--model", model,
            "--max-turns", str(max_turns),
        ]
        if self.config.project_id:
            cmd.extend(["--vertex-project", self.config.project_id])
        if extra_args:
            cmd.extend(extra_args)
        cmd.extend(["--prompt", prompt])
        return cmd
```

***

## **10. Claude Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ°: `src/infrastructure/claude/factory.py`**

```python
from src.config.settings import ClaudeConfig, CloudProvider
from src.domain.exceptions import ConfigurationError
from .providers import ClaudeProvider, DirectAPIProvider, BedrockProvider, VertexProvider


class ClaudeProviderFactory:
    _providers = {
        CloudProvider.API: DirectAPIProvider,
        CloudProvider.BEDROCK: BedrockProvider,
        CloudProvider.VERTEX: VertexProvider,
    }

    @staticmethod
    def create(config: ClaudeConfig) -> ClaudeProvider:
        provider_class = ClaudeProviderFactory._providers.get(config.provider)
        if provider_class is None:
            raise ConfigurationError(f"Unknown provider: {config.provider}")
        return provider_class(config)
```

***

## **11. Claude ĞºĞ»Ğ¸ĞµĞ½Ñ‚: `src/infrastructure/claude/client.py`**

```python
from typing import List, Optional
from src.config.settings import ClaudeConfig
from src.config.logger import LoggerFactory
from src.infrastructure.shell.executor import ShellExecutor
from src.domain.exceptions import ClaudeExecutionError, ConfigurationError
from .factory import ClaudeProviderFactory
from src.utils.result import Result


class ClaudeClient:
    def __init__(self, config: ClaudeConfig):
        self.config = config
        self.logger = LoggerFactory.get_logger(__name__)
        self.executor = ShellExecutor()
        self._validate_config()
        self.provider = ClaudeProviderFactory.create(config)

    def _validate_config(self):
        if self.config.provider == "api" and not self.config.api_key:
            raise ConfigurationError("CLAUDE_API_KEY required for API provider")
        if self.config.provider == "vertex" and not self.config.project_id:
            raise ConfigurationError("GCP_PROJECT_ID required for Vertex provider")

    def execute(
        self,
        prompt: str,
        model: Optional[str] = None,
        max_turns: Optional[int] = None,
        extra_args: Optional[List[str]] = None
    ) -> Result[str]:
        try:
            model = model or self.config.model
            max_turns = max_turns or self.config.max_turns
            
            command = self.provider.build_command(model, max_turns, prompt, extra_args)
            returncode, stdout, stderr = self.executor.execute(command, self.config.timeout)
            
            if returncode != 0:
                return Result.err(ClaudeExecutionError(f"Claude failed: {stderr}"))
            
            return Result.ok(stdout)
        except Exception as e:
            self.logger.error(f"Execution error: {str(e)}")
            return Result.err(e if isinstance(e, ClaudeExecutionError) else ClaudeExecutionError(str(e)))
```

***

## **12. GitHub Workflows: `src/infrastructure/github/workflows.py`**

```python
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from src.config.settings import Settings
from src.config.logger import LoggerFactory
from src.domain.exceptions import ClaudeIntegrationException


class WorkflowGenerator:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = LoggerFactory.get_logger(__name__)
        self.workflows_dir = settings.project_root / ".github" / "workflows"

    def generate_all(self):
        templates = {
            "claude-pr.yml": "bedrock",
            "claude-api.yml": "api",
            "claude-vertex.yml": "vertex",
            "claude-review.yml": "review",
            "claude-daily-report.yml": "daily",
        }

        for filename, template_name in templates.items():
            self._generate_workflow(filename, template_name)
            self.logger.info(f"Generated {filename}")

    def _generate_workflow(self, filename: str, template_name: str):
        self.workflows_dir.mkdir(parents=True, exist_ok=True)
        
        env = Environment(loader=FileSystemLoader(self.settings.project_root / "templates" / "workflows"))
        template = env.get_template(f"{template_name}.yml.jinja2")
        
        content = template.render()
        filepath = self.workflows_dir / filename
        filepath.write_text(content)
```

***

## **13. Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ UseCase: `src/application/use_cases/base.py`**

```python
from abc import ABC, abstractmethod
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.config.logger import LoggerFactory
from src.infrastructure.claude.client import ClaudeClient
from src.domain.exceptions import ClaudeIntegrationException


class UseCase(ABC):
    def __init__(self, claude_client: ClaudeClient):
        self.claude_client = claude_client
        self.logger = LoggerFactory.get_logger(__name__)

    @abstractmethod
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        pass

    def _build_result(self, success: bool, output: str, error: str = None, exit_code: int = 0) -> TaskResultDTO:
        return TaskResultDTO(success=success, output=output, error=error, exit_code=exit_code)

    def _load_prompt(self, filename: str) -> str:
        from src.config.settings import Settings
        settings = Settings.from_env()
        filepath = settings.prompts_dir / f"{filename}.yml"
        
        if not filepath.exists():
            raise ClaudeIntegrationException(f"Prompt file not found: {filepath}")
        
        import yaml
        with open(filepath, "r") as f:
            data = yaml.safe_load(f)
            return data.get("prompt", "")
```

***

## **14. Use Cases ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ:**

### **Review: `src/application/use_cases/review.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class ReviewUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        pr_number = dto.extra_params.get("pr")
        if not pr_number:
            return self._build_result(False, "", "PR number required", 1)

        prompt = dto.prompt_override or self._load_prompt("review").format(pr_number=pr_number)
        max_turns = dto.max_turns_override or 5

        result = self.claude_client.execute(prompt, max_turns=max_turns)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

### **Implement: `src/application/use_cases/implement.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class ImplementUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        issue_number = dto.extra_params.get("issue")
        if not issue_number:
            return self._build_result(False, "", "Issue number required", 1)

        prompt = dto.prompt_override or self._load_prompt("implement").format(issue_number=issue_number)
        max_turns = dto.max_turns_override or 15

        result = self.claude_client.execute(prompt, max_turns=max_turns)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

### **Fix: `src/application/use_cases/fix.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class FixUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        bug_description = dto.extra_params.get("bug")
        if not bug_description:
            return self._build_result(False, "", "Bug description required", 1)

        prompt = dto.prompt_override or self._load_prompt("fix").format(bug_description=bug_description)

        result = self.claude_client.execute(prompt)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

### **Docs: `src/application/use_cases/docs.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class DocsUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        scope = dto.extra_params.get("scope", ".")

        prompt = dto.prompt_override or self._load_prompt("docs").format(scope=scope)
        max_turns = dto.max_turns_override or 8

        result = self.claude_client.execute(prompt, max_turns=max_turns)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

### **Refactor: `src/application/use_cases/refactor.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class RefactorUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        module = dto.extra_params.get("module")
        if not module:
            return self._build_result(False, "", "Module path required", 1)

        prompt = dto.prompt_override or self._load_prompt("refactor").format(module=module)
        max_turns = dto.max_turns_override or 12

        result = self.claude_client.execute(prompt, max_turns=max_turns)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

### **Tests: `src/application/use_cases/tests.py`**

```python
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.application.use_cases.base import UseCase


class TestsUseCase(UseCase):
    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        module = dto.extra_params.get("module")
        if not module:
            return self._build_result(False, "", "Module path required", 1)

        prompt = dto.prompt_override or self._load_prompt("tests").format(module=module)
        max_turns = dto.max_turns_override or 10

        result = self.claude_client.execute(prompt, max_turns=max_turns)
        
        if result.is_ok:
            return self._build_result(True, result.value)
        
        return self._build_result(False, "", str(result.error), 1)
```

***

## **15. Use Cases Ñ€ĞµĞµÑÑ‚Ñ€: `src/application/use_cases/__init__.py`**

```python
from src.application.use_cases.review import ReviewUseCase
from src.application.use_cases.implement import ImplementUseCase
from src.application.use_cases.fix import FixUseCase
from src.application.use_cases.docs import DocsUseCase
from src.application.use_cases.refactor import RefactorUseCase
from src.application.use_cases.tests import TestsUseCase
from src.domain.entities import TaskType
from src.infrastructure.claude.client import ClaudeClient


class UseCaseRegistry:
    def __init__(self, claude_client: ClaudeClient):
        self._use_cases = {
            TaskType.REVIEW: ReviewUseCase(claude_client),
            TaskType.IMPLEMENT: ImplementUseCase(claude_client),
            TaskType.FIX: FixUseCase(claude_client),
            TaskType.DOCS: DocsUseCase(claude_client),
            TaskType.REFACTOR: RefactorUseCase(claude_client),
            TaskType.TESTS: TestsUseCase(claude_client),
        }

    def get(self, task_type: TaskType):
        return self._use_cases.get(task_type)
```

***

## **16. ĞĞ¿Ğ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²Ğ¸Ñ: `src/application/service.py`**

```python
from src.config.settings import Settings
from src.config.logger import LoggerFactory
from src.infrastructure.claude.client import ClaudeClient
from src.application.use_cases import UseCaseRegistry
from src.application.dto import ExecuteTaskDTO, TaskResultDTO
from src.domain.entities import TaskType
from src.domain.exceptions import InvalidTaskError


class TaskExecutor:
    def __init__(self, settings: Settings = None):
        self.settings = settings or Settings.from_env()
        self.logger = LoggerFactory.get_logger(__name__)
        self.claude_client = ClaudeClient(self.settings.claude)
        self.registry = UseCaseRegistry(self.claude_client)

    def execute(self, dto: ExecuteTaskDTO) -> TaskResultDTO:
        try:
            use_case = self.registry.get(dto.task_type)
            if not use_case:
                raise InvalidTaskError(f"Unknown task type: {dto.task_type}")
            
            return use_case.execute(dto)
        except Exception as e:
            self.logger.error(f"Task execution failed: {str(e)}")
            return TaskResultDTO(success=False, output="", error=str(e), exit_code=1)
```

***

## **17. Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ĞµÑ€: `src/presentation/formatter.py`**

```python
from src.application.dto import TaskResultDTO


class OutputFormatter:
    @staticmethod
    def format_result(result: TaskResultDTO) -> str:
        if result.success:
            return f"âœ“ Success\n{result.output}"
        
        error_msg = f"\n{result.error}" if result.error else ""
        return f"âŒ Failed (exit code: {result.exit_code}){error_msg}"

    @staticmethod
    def format_json(result: TaskResultDTO) -> str:
        import json
        return json.dumps({
            "success": result.success,
            "output": result.output,
            "error": result.error,
            "exit_code": result.exit_code
        })
```

***

## **18. CLI Ğ¿Ğ°Ñ€ÑĞµÑ€: `src/presentation/parser.py`**

```python
import argparse
from src.domain.entities import TaskType


class ArgumentParser:
    @staticmethod
    def parse(args) -> dict:
        parser = argparse.ArgumentParser(
            description="Claude Code Integration Manager",
            formatter_class=argparse.RawDescriptionHelpFormatter
        )
        
        subparsers = parser.add_subparsers(dest="command", help="Commands")
        
        run_parser = subparsers.add_parser("run")
        run_parser.add_argument("prompt")
        run_parser.add_argument("--model")
        run_parser.add_argument("--max-turns", type=int)
        
        review_parser = subparsers.add_parser("review")
        review_parser.add_argument("--pr", type=int, required=True)
        review_parser.add_argument("--max-turns", type=int)
        
        impl_parser = subparsers.add_parser("implement")
        impl_parser.add_argument("--issue", type=int, required=True)
        impl_parser.add_argument("--max-turns", type=int)
        
        fix_parser = subparsers.add_parser("fix")
        fix_parser.add_argument("--bug", required=True)
        fix_parser.add_argument("--max-turns", type=int)
        
        docs_parser = subparsers.add_parser("docs")
        docs_parser.add_argument("--scope", default=".")
        docs_parser.add_argument("--max-turns", type=int)
        
        refactor_parser = subparsers.add_parser("refactor")
        refactor_parser.add_argument("--module", required=True)
        refactor_parser.add_argument("--max-turns", type=int)
        
        tests_parser = subparsers.add_parser("tests")
        tests_parser.add_argument("--module", required=True)
        tests_parser.add_argument("--max-turns", type=int)
        
        return vars(parser.parse_args(args))
```

***

## **19. CLI: `src/presentation/cli.py`**

```python
import sys
from src.presentation.parser import ArgumentParser
from src.presentation.formatter import OutputFormatter
from src.application.service import TaskExecutor
from src.application.dto import ExecuteTaskDTO
from src.domain.entities import TaskType
from src.config.logger import LoggerFactory


class CLIApplication:
    def __init__(self):
        self.logger = LoggerFactory.get_logger(__name__)
        self.executor = TaskExecutor()
        self.formatter = OutputFormatter()

    def run(self, args):
        try:
            parsed = ArgumentParser.parse(args)
            
            if not parsed.get("command"):
                self.logger.error("No command specified")
                return 1
            
            command = parsed["command"]
            
            if command == "run":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.REVIEW,
                    prompt_override=parsed["prompt"],
                    max_turns_override=parsed.get("max_turns")
                )
            elif command == "review":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.REVIEW,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"pr": parsed["pr"]}
                )
            elif command == "implement":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.IMPLEMENT,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"issue": parsed["issue"]}
                )
            elif command == "fix":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.FIX,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"bug": parsed["bug"]}
                )
            elif command == "docs":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.DOCS,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"scope": parsed.get("scope", ".")}
                )
            elif command == "refactor":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.REFACTOR,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"module": parsed["module"]}
                )
            elif command == "tests":
                dto = ExecuteTaskDTO(
                    task_type=TaskType.TESTS,
                    max_turns_override=parsed.get("max_turns"),
                    extra_params={"module": parsed["module"]}
                )
            else:
                self.logger.error(f"Unknown command: {command}")
                return 1
            
            result = self.executor.execute(dto)
            print(self.formatter.format_result(result))
            
            return 0 if result.success else 1
        except Exception as e:
            self.logger.error(f"CLI error: {str(e)}")
            return 1

    @staticmethod
    def main():
        app = CLIApplication()
        sys.exit(app.run(sys.argv[1:]))
```

***

## **20. Main entry point: `src/main.py`**

```python
from src.presentation.cli import CLIApplication


if __name__ == "__main__":
    CLIApplication.main()
```

***

## **21. Prompt Ñ„Ğ°Ğ¹Ğ»Ñ‹:**

### **`prompts/review.yml`**

```yaml
prompt: |
  Review pull request #{pr_number} for:
  - Security vulnerabilities
  - Performance issues
  - Code style consistency
  - Test coverage
  - Documentation quality
  
  Provide actionable feedback and suggestions.
```

### **`prompts/implement.yml`**

```yaml
prompt: |
  Implement the feature described in issue #{issue_number}.
  
  Requirements:
  - Follow project coding standards
  - Include comprehensive tests
  - Update documentation
  - Ensure backward compatibility
```

### **`prompts/fix.yml`**

```yaml
prompt: |
  Fix this bug: {bug_description}
  
  Steps:
  1. Analyze the root cause
  2. Implement a fix
  3. Add tests to prevent regression
  4. Update documentation if needed
```

### **`prompts/docs.yml`**

```yaml
prompt: |
  Generate comprehensive documentation for {scope}:
  
  Include:
  - README with setup instructions
  - API documentation
  - Usage examples
  - Configuration guide
  - Architecture overview
```

### **`prompts/refactor.yml`**

```yaml
prompt: |
  Refactor {module} for:
  - Code readability
  - Performance optimization
  - Design pattern compliance
  - SOLID principles adherence
  
  Maintain existing functionality and tests.
```

### **`prompts/tests.yml`**

```yaml
prompt: |
  Write comprehensive tests for {module}:
  
  Requirements:
  - Unit tests for all functions
  - Integration tests
  - Edge cases coverage
  - Minimum 80% code coverage
  - Clear test descriptions
```

***

## **22. `__init__.py` Ñ„Ğ°Ğ¹Ğ»Ñ‹:**

### **`src/__init__.py`**

```python
from src.application.service import TaskExecutor
from src.config.settings import Settings

__version__ = "1.0.0"
__all__ = ["TaskExecutor", "Settings"]
```

### **`src/config/__init__.py`**

```python
from src.config.settings import Settings, ClaudeConfig, LoggerConfig
from src.config.logger import LoggerFactory

__all__ = ["Settings", "ClaudeConfig", "LoggerConfig", "LoggerFactory"]
```

### **`src/domain/__init__.py`**

```python
from src.domain.entities import Task, ExecutionResult, TaskType, TaskStatus
from src.domain.exceptions import ClaudeIntegrationException

__all__ = ["Task", "ExecutionResult", "TaskType", "TaskStatus", "ClaudeIntegrationException"]
```

### **`src/application/__init__.py`**

```python
from src.application.service import TaskExecutor
from src.application.dto import ExecuteTaskDTO, TaskResultDTO

__all__ = ["TaskExecutor", "ExecuteTaskDTO", "TaskResultDTO"]
```

### **`src/infrastructure/__init__.py`**

```python
from src.infrastructure.claude.client import ClaudeClient
from src.infrastructure.shell.executor import ShellExecutor

__all__ = ["ClaudeClient", "ShellExecutor"]
```

### **`src/presentation/__init__.py`**

```python
from src.presentation.cli import CLIApplication

__all__ = ["CLIApplication"]
```

### **`src/utils/__init__.py`**

```python
from src.utils.result import Result

__all__ = ["Result"]
```

***

## **23. `pyproject.toml`**

```toml
[tool.poetry]
name = "claude-integration"
version = "1.0.0"
description = "Enterprise Claude Code GitHub Actions Integration"
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.9"
python-dotenv = "^1.0.0"
jinja2 = "^3.1.0"
pyyaml = "^6.0"
anthropic = "^0.7.0"

[tool.poetry.dev-dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
black = "^23.0.0"
pylint = "^2.17.0"
mypy = "^1.4.0"
ruff = "^0.0.285"

[tool.black]
line-length = 120
target-version = ['py39', 'py310', 'py311']

[tool.pylint.messages_control]
disable = ["C0111", "C0103"]

[tool.pylint.format]
max-line-length = 120

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false

[tool.ruff]
line-length = 120
select = ["E", "F", "W"]
```

***

## **24. Makefile (Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹)**

```makefile
.PHONY: help setup install lint format test clean run docker-build

PYTHON := python3
POETRY := poetry

help:
	@echo "Claude Integration - Commands"
	@echo "make setup        - Install dependencies"
	@echo "make install      - Install Claude CLI"
	@echo "make lint         - Run linters (black, pylint, mypy)"
	@echo "make format       - Format code"
	@echo "make test         - Run tests"
	@echo "make clean        - Clean build artifacts"

setup:
	$(POETRY) install

install:
	curl -fsSL https://claude.ai/install.sh | bash

lint:
	$(PYTHON) -m black --check src tests
	$(PYTHON) -m pylint src
	$(PYTHON) -m mypy src

format:
	$(PYTHON) -m black src tests
	$(PYTHON) -m ruff --fix src tests

test:
	$(PYTHON) -m pytest tests -v --cov=src --cov-report=html

clean:
	find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true
	find . -type f -name "*.pyc" -delete
	rm -rf .pytest_cache .coverage htmlcov dist build *.egg-info

docker-build:
	docker build -t claude-integration:latest .

run:
	$(PYTHON) -m src.main
```

***

## **25. Bash ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:**

### **`scripts/analyze.sh`**

```bash
#!/bin/bash

set -e

echo "ğŸ“Š Code Analysis..."

echo "ğŸ” Finding Python files..."
fd -e py --type f . src

echo "ğŸ“ˆ Code complexity..."
rg -t py 'def |class ' src | wc -l

echo "ğŸ” Finding duplicates..."
rg -t py --count-matches '^\s+\w+\s*=' src

echo "âœ“ Analysis complete"
```

### **`scripts/setup.sh`**

```bash
#!/bin/bash

set -e

echo "âš™ï¸  Setting up Claude Integration..."

if ! command -v python3 &> /dev/null; then
    echo "âŒ Python3 not found"
    exit 1
fi

if ! command -v poetry &> /dev/null; then
    echo "ğŸ“¦ Installing Poetry..."
    pip install poetry
fi

echo "ğŸ“¦ Installing dependencies..."
poetry install

echo "ğŸ“¥ Installing Claude CLI..."
curl -fsSL https://claude.ai/install.sh | bash

echo "âœ“ Setup complete"
```

***

## **26. requirements.txt (Ğ´Ğ»Ñ pip)**

```
python-dotenv>=1.0.0
jinja2>=3.1.0
pyyaml>=6.0
anthropic>=0.7.0
pytest>=7.4.0
pytest-cov>=4.1.0
black>=23.0.0
pylint>=2.17.0
mypy>=1.4.0
ruff>=0.0.285
```

***

## **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Presentation Layer (CLI)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ArgumentParser â”‚ OutputFormatter â”‚ CLI App â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Application Layer (Service)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ TaskExecutor â”‚ Use Cases â”‚ DTO â”‚ Service  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Domain Layer (Entities & Rules)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Task â”‚ Result â”‚ Enums â”‚ Exceptions â”‚ Rules â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Infrastructure Layer (External Tools)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Claude Client â”‚ Shell â”‚ GitHub â”‚ Workflows â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ°:**

âœ“ **SOLID** - ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ¾Ğ´Ğ½Ğ° Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ  
âœ“ **DRY** - Ğ½ĞµÑ‚ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ²  
âœ“ **KISS** - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¸ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾  
âœ“ **GoF Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** - Factory, Strategy, Repository  
âœ“ **ĞœĞ½Ğ¾Ğ³Ğ¾ÑĞ»Ğ¾Ğ¹Ğ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°** - Ñ‡Ñ‘Ñ‚ĞºĞ¾Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ  
âœ“ **ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ²Ñ‹Ğ½ĞµÑĞµĞ½Ğ°** - Settings, YAML  
âœ“ **Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - dependency injection  
âœ“ **Type hints** - Ğ¿Ğ¾Ğ»Ğ½Ğ°Ñ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ  
âœ“ **ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ»ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ use cases